////////////////////////////////////////////////////
// PolyText
// author: Stephen Gannon
// date: 27/11/19
// purpose: Contains and explanation of designed data type, specifications and pseudo-code for
//          all operations
////////////////////////////////////////////////////


////////////////////////////////////////////////////
// Specifications and  Pseudo-code for all operations
////////////////////////////////////////////////////

polyList polyDeclare()
{

}


///////////////////////////////////////////////////
// Name: polyCreate()
// Purpose: Creates and empty polynomial, head points
//          to tail and has no coeffiecients.
// Parameters: Use fillPoly() or newCoeff() to add
//             new coefficiients.
// return: pointer to polynomial if successful
//   	   NULL if unsuccessful
///////////////////////////////////////////////////

polyList *polyCreate()
{
	creates a polyList and assigns it the required memory with malloc
	checks for allocation success
	allocates memory for the head
	if allocation fails
	   deallocate list and set it to NULL
	return poly
}


//////////////////////////////////////////////////
// Name: fillPoly
// Purpose: Fills an empty polynomial of a
//          certain order with coefficients in arr[]
// Parameters: poly - the empty polynomial to fill
// 	       order - the order of the polynomial
//	       arr - the array of coefficients
// Return: Pointer to polynomial if successful
//////////////////////////////////////////////////

int fillPoly(polyList, order, array)
{
	fill polyList parameters
	assign head coefficients
	for all the powers of x
	    assign the coefficients
	    set current to next
	reset currnet to head
}


//////////////////////////////////////////////////
// Name: newCoeff
// Purpose: Creates and returns a new polyNode to
// 	    be added to the next node of the
//	    previous node
// Parameters: coefficient - the value of the coefficient
//   	       order - the order of the coefficient
// Return:  pointer to the new node, if successful
//////////////////////////////////////////////////

polyNode *newCoeff(coefficient, order)
{
	allocate memory for the new node
	exit if allocation results in a NULL
	assign attributes
	link node to current node
}


//////////////////////////////////////////////////
// Name: polyDelete()
// Purpose: Deletes and frees up memory from a
// 	    polynomial
// Parameters: poly - the to delete
// Return: returns 0 if successful
//////////////////////////////////////////////////

polyDelete(address of polylist)
{
	reset current to head
	while (there is a next node)
	      delete current node
	free head and polynomial
}


//////////////////////////////////////////////////
// Name: deleteNext
// Purpose: Deletes and frees up memory for the next
// 	    node after the current node specified
// Parameters: toDelete - the coefficient node to
// 	       to delete
// Return: returns 0 if successful
//////////////////////////////////////////////////

Int deleteNext(ptr to current address)
{
	sets a node to delete
	if reaches tail
	   return -1
	else
	   keeps ptr to node to be deleted
	   set next to current
	   delete node from memory
}



polyList polyAdd(polylist1, polylist2)
{
	 If polylist1 >= polylist2
	    Create polylist of size order+1
	    For loop (for order of polylist 2)
    	    	Add all elements for smaller polylist
    	    For loop (for order of polylist 1 - polylist 2)
    		Add all elements to 0 for overflow
	 Else 
            create polylist of size order+1
    	    For loop (for order of polylist 1)
    	    	Add all elements for smaller polylist
            For loop (for order of polylist 2 - polylist 1)
    	    	Add all elements to 0 for overflow
}

polyList polySubtract(polylist1, polylist2)
{
	 If polylist1 >= polylist2
            Create polylist of size order+1
	    For loop (for order of polylist 2)
    	    	subtract all elements for smaller polylist
	     For loop (for order of polylist 1 - polylist 2)
    	     	Make all terms negative
	 Else 
             Create polylist of size order+1
	     For loop (for order of polylist 1)
    	     	 subtract all elements for smaller polylist
	     For loop (for order of polylist 2 - polylist 1)
    	         Leave all elements as they are
}

polyList multiply(polylist, multiplier)
{
	Create polylist of size polylist
    	For loop(for order of polylist)
            Polylist[i] * multiplier
    	Return 
}


polyList divide(polylist, divider)
{
	For loop( for order of polylist)
            Polylist[i] / divider
    	Return
}


Polylist normalise(polylist)
{
	 Order = order(polylist)
    	 For loop of order(polylist) 
    	     highCoeff = current value
    	     polyList divide(polylist, highCoeff)
    	 return
}


Int order(polylist)
{
    Int order
    For order of the polylist 
        If the element is non-zero
            Order = order of element
}


Void print(polylist)
{
	Prints first coefficient
	For loop for remaining 
	    Prints the remaining coefficients with respective order
}

